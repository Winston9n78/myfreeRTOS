#include "task.h"

#if(configSUPPORT_STATIC_ALLOCATION == 1)

TCB_t * pxCurrentTCB;

List_t pxReadyTasksLists[ configMAX_PRIORITIES ];

extern TCB_t Task1TCB;
extern TCB_t Task2TCB;

extern TCB_t IdleTaskTCB;



//void vApplicationGetIdleTaskMemory( TCB_t **ppxIdleTaskTCBBuffer,
//																		StackType_t **ppxIdleTaskStackBuffer,
//																		uint32_t *pulIdleTaskStackSize );

static void prvInitialiseNewTask(	TaskFunction_t pxTaskCode,
																	const char *const pcName,
																	const uint32_t ulStackDepth,
																	void * const pvParameters,
																	TaskHandle_t *const pxCreatedTask,
																	TCB_t *pxNewTCB )
{
	StackType_t *pxTopOfStack;
	UBaseType_t x;
	/* 获取栈顶地址 */
	pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1);
	/* 向下做8字节对齐 */
	pxTopOfStack = ( StackType_t * ) \
									(( ( uint32_t ) pxTopOfStack )&(~( ( uint32_t ) 0x0007 ) ));
	
	/*将任务名存储在TCB中 */
	for ( x = ( UBaseType_t )0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
		
		if ( pcName[ x ] == 0x00 )
		{
			break;
		}
	}
	
	/*任务名的长度不能超过configMAX_TASK_NAME_LEN */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN -1 ]= '\0';
	
	/*初始化TCB中的xStateListItem节点*/
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	
	/*设置xStateListItem节点的拥有者*/
	listSET_LIST_ITEM_OWNER(&( pxNewTCB->xStateListItem ), pxNewTCB );
	
	/*初始化任务栈*/
	pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack,
																									pxTaskCode,
																									pvParameters);
	
	if( ( void * ) pxCreatedTask != NULL)
	{
		*pxCreatedTask = (TaskHandle_t ) pxNewTCB;
	}
}

	


TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,
																const char *const pcName,
																const uint32_t ulStackDepth,
															  void * const pvParameters,
																StackType_t * const puxStackBuffer,
																TCB_t * const pxTaskBuffer )
{
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;
	
	if((pxTaskBuffer != NULL) && (puxStackBuffer !=NULL))
	{
		pxNewTCB = (TCB_t * ) pxTaskBuffer;
		pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
		
		/* 创建新的任务 */
		prvInitialiseNewTask( pxTaskCode,  		/*任务入口*/
													pcName,			 		/*任务名称，字符串形式*/
													ulStackDepth,		/*任务栈大小，单位为字*/
													pvParameters,		/*任务形参*/
													&xReturn,		 		/*任务句柄*/
													pxNewTCB);	 		/*任务栈起始地址*/
	}
	else
	{
		xReturn = NULL;
	}

	/*返回任务句柄，如果任务创建成功，此时xReturn应该指向任务控制块*/
	return xReturn;
}


/*任务就绪列表初始化*/
void prvInitialiseTaskLists( void )
{
	UBaseType_t uxPriority;
	for ( uxPriority = (UBaseType_t ) 0U;
				uxPriority <(UBaseType_t ) configMAX_PRIORITIES;uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

}

/* 启动调度器 */
void vTaskStartScheduler( void )
{
	

	
	/* 手动指定第一个运行的任务 */
	pxCurrentTCB = &Task1TCB;
	
	/* 启动调度器 */
	if ( xPortStartScheduler() != pdFALSE )
	{
		/* 调度器启动成功，则不会返回，即不会来到这里 */
	}
}

/* 阻塞延时函数 */
void vTaskDelay(const TickType_t xTicksToDelay)
{
	TCB_t *pxTCB = NULL;
	/*获取当前任务的TCB*/
	pxTCB = pxCurrentTCB;
	
	/*设置延时时间*/
	pxTCB->xTicksToDelay = xTicksToDelay;
	
	/*任务切换*/
	taskYIELD(); /*触发PendSv，产生上下文切换*/ 
}

/* 任务切换 */
#if 0
void vTaskSwitchContext ( void )
{
	/*两个任务轮流切换*/
	if ( pxCurrentTCB == &Task1TCB )
	{
		pxCurrentTCB = &Task2TCB;
	}
	
	else
	{
		pxCurrentTCB = &Task1TCB;
	}
}
#else
void vTaskSwitchContext ( void )
{
	/*如果当前任务是空闲任务，那么就去尝试执行任务1或者任务2，
	看看它们的延时是否结束，如果任务的延时均没有到期，则返回，继续执行空闲任务*/
	if ( pxCurrentTCB == &IdleTaskTCB )
	{
		if ( Task1TCB.xTicksToDelay == 0)
		{
			pxCurrentTCB = &Task1TCB;
		}
		
		else if( Task2TCB.xTicksToDelay  == 0)
		{
			pxCurrentTCB = &Task2TCB;
		}		
		else
		{
			return; /*任务延时均没有到期则返回，继续执行空闲任务*/
		}
	}
	
	else /*当前任务不是空闲任务则会执行到这里*/
	{
		/*如果当前任务是任务1或者任务2，检查另外一个任务，
		如果另外的任务不在延时中，就切换到该任务，
		否则，判断当前任务是否应该进入延时状态，
		如果是，就切换到空闲任务，否则不进行任何切换*/
		if (pxCurrentTCB ==&Task1TCB)
		{
			if (Task2TCB.xTicksToDelay ==0)
			{
				pxCurrentTCB =&Task2TCB;
			}
			else if (pxCurrentTCB->xTicksToDelay != 0)
			{
				pxCurrentTCB = &IdleTaskTCB;
			}
			else
			{
				return; /*返回，不进行切换,因为两个任务都处于延时中*/
			}		
		}
		
		else if (pxCurrentTCB ==&Task2TCB)
		{
			if (Task1TCB.xTicksToDelay ==0)
			{
				pxCurrentTCB =&Task1TCB;
			}
			else if (pxCurrentTCB->xTicksToDelay != 0)
			{
				pxCurrentTCB = &IdleTaskTCB;
			}
			else
			{
				return; /*返回，不进行切换,因为两个任务都处于延时中*/
			}
		
		}
		
	}

}

#endif

extern unsigned int xTickCount;
void xTaskIncrementTick( void )
{
	TCB_t*pxTCB = NULL;
	BaseType_t i = 0;
	/*更新系统时基计数器xTickCount，xTickCount是一个在port.c中定义的全局变量*/
	const TickType_t xConstTickCount = xTickCount + 1;
	xTickCount = xConstTickCount;
	
	/*扫描就绪列表中所有任务的xTicksToDelay，如果不为0，则减1 */
	for (i=0; i<configMAX_PRIORITIES; i++)
	{
	
		pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&pxReadyTasksLists[i]));/* 新加入list.h中 */
		if (pxTCB->xTicksToDelay > 0)
		{
			pxTCB->xTicksToDelay --;
		}
	}
	
	/*任务切换*/
	taskYIELD();
	
}

__asm void vPortSVCHandler( void )
{	

		extern pxCurrentTCB;
	
		PRESERVE8	
	
		ldr r3, =pxCurrentTCB 
		ldr r1,[r3]					  
		ldr r0,[r1]					  
		ldmia r0!, {r4-r11}   
		msr psp,r0            
		isb                   
		mov r0,#0             
		msr basepri,r0        
		orr r14,#0xd          
		bx r14                
			
}

__asm void xPortPendSVHandler( void )
{

		extern vTaskSwitchContext;
		extern pxCurrentTCB;	
		                                              
		PRESERVE8                                     
		                                              
		mrs r0, psp                                   
		isb                                           
		                                              
		ldr r3, = pxCurrentTCB                        
		ldr r2,[r3] 

		stmdb r0!,{r4-r11}
		str r0,[r2]
		                                              
		stmdb sp!, {r3, r14}                          
		mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY 
		msr basepri,r0                                
		dsb                                           
		isb                                           
		bl vTaskSwitchContext                         
		mov r0,#0                                     
		msr basepri,r0                                
		ldmia sp!, {r3, r14}                          
		                                              
		ldr r1,[r3]                                   
		ldr r0,[r1]                                   
		ldmia r0!,{r4-r11}                            
		msr psp,r0                                    
		isb                                           
		bx r14                                        
		nop                                           
	
}



#endif
